1
1) System decomposition 
    Procedural paradigm จะแตกย่อยระบบหรือซอฟแวร์ออกมาเป็นฟังก์ชัน
    OO จะแตกย่อยระบบหรือซอฟแวร์ออกมาเป็น class/object
2) การทำงานกับ Data
    Procedural paradigm จะมีฟังก์ชันที่ทำงานกับ data โดยตรง
    OO จะมี Object ที่ encapsulate data (attribute) และมี method (เปรียบเสมือน function) ที่ทำงานกับ data
3) Inheritance concept
    Procedural paradigm ไม่มี inheritance ทำให้ code reusability นั้นจำกัด
    OO มี inheritance ทำให้เพิ่ม code reusability จากการสร้าง class ใหม่โดยการ inherit class ที่มีอยู่แล้ว
4) Abstraction
    Procedural paradigm จะเน้นไปที่ procedural abstraction นั่นคือจะซ่อนรายละเอียด implementation จากผู้ที่เรียกใช้ฟังก์ชัน
    OO จะเน้นทั้ง data และ procedural abstraction นั่นคือมีส่วนของการซ่อนข้อมูลภายในของ object รวมถึงรายละเอียด implementation ของ method ด้วย
5) Real-World Mapping
    Procedural paradigm จะไม่สามาถ map กับ entity ในโลกจริงๆได้โดยตรง
    OO นั้นมี object ที่เป็นตัวแทนของ entity ในโลกจริงๆได้

2
Abstraction -> เป็น concept ของการลดความซับซ้อนของระบบโดยซ่อนรายละเอียดที่ไม่จำเป็น และเปิดเผยเฉพาะรายละเอียดที่จำเป็นเท่านั้น หรือเป็นการโฟกัสไปที่ว่า object นี้ทำอะไรได้บ้าง ไม่ได้โฟกัสที่ภายใน object นั้นว่าทำงานอย่างไร
Encapsulation -> เป็นการห่อหุ้มตัว data (attribute) และ method รวมเป็นยูนิตที่เรียกว่า class ทำให้มี information hiding และ controlled access นั่นคือจะปกปิดข้อมูลภายใน class/object และสามารถจำกัดการเข้าถึง data (attribute) ให้สามารถเข้าถึงได้ผ่าน method ที่ class มีให้เท่านั้น
Inheritance -> คือการถ่ายทอด attribute และ method จาก superclass ไปสู่ subclass ทำให้ตัว subclass มีพื้นฐานที่เหมือนกับ superclass แต่สามารถเพิ่ม attribute หรือเพิ่ม/แก้ไข method ได้ (Specialization)
Polymorphism ->  คือการที่หลายๆ object ที่อยู่ class ต่างกันมีการตอบสนองที่แตกต่างกันผ่าน method ชื่อเดียวกัน หรือคือการมี method เดียวกันในหลายๆ version ที่ไม่เหมือนกัน ขึ้นอยู่กับการ implement ของแต่ละ class
Cohesion -> ระดับความเกี่ยวข้องกันของกลุ่มของ class ภายใน subsystem/module/package ยิ่งมีระดับ Cohesion ที่สูงนั้นหมายความว่า class เหล่านี้ทำงานที่เกี่ยวข้องกันอย่างมาก และทำงานเพื่อวัตถุประสงค์บางอย่างที่กำหนดไว้อย่างชัดเจน
Coupling -> คือระดับที่ class/subsystem หนึ่งมีการทำงานที่ไปขึ้นกับอีก class/subsystem หนึ่ง ยิ่งระดับ Coupling ต่ำนั้้นหมายความว่าการเปลี่ยนแปลงที่ class/subsystem หนึ่งจะมีผลกระทบต่ออีก class/subsystem ที่น้อย

3.1) วิเคราะห์และทำความเข้าใจปัญหาใน software/application Domain ร่วมกับ requirement เช่น user story, use case diagrams แล้วระบุคำนามที่แสดงถึง concept หรือ entity ใน Domain คำนามเหล่านี้จะเป็น candidate สำหรับการสร้าง class
หลังจากนั้นต้องทำการมองหาความรับผิดชอบของ entity เหล่านี้ โดยกิจกรรมหรือพฤติกรรมของ entity เหล่านี้สามารถนำมาเป็น method ของ class ได้ วิเคราะห์หาความสัมพันธ์ของแต่ละ entity จนสุดท้ายจะได้มาเป็น class ของระบบ
3.2) แต่ละ subsystem/package ควรมีหน้าที่รับผิดชอบที่ชัดเจน และควรแบ่งระบบย่อยให้มี high cohesion นั่นคือแต่ละ class ใน subsystem/package จะต้องทำงานเกี่ยวข้องกันมากๆ และมีจุดประสงค์ร่วมกันที่ชัดเจน รวมถึงควรแบ่งให้มี low Coupling นั่นคือแต่ละ subsystem/package ควรพึ่งพาหรือขึ้นกับอีก subsystem/package ให้น้อยที่สุด หรืออาจนำ Decomposition Techniques มาใช้
เช่น แบ่ง subsystem เป็น layer โดย layer ที่ต่ำกว่าจะให้ service กับ layer ที่อยู่สูงกว่า

4.
1) Security -> มีความสำคัญอย่างมาก เพราะอุปกรณ์คอมพิวเตอร์เป็นทรัพย์สินที่มูลค่าของโรงเรียน ดังนั้นระบบต้องมีความปลอดภัย โดยป้องกันไม่ให้มีการแอบอ้างหรือหาช่องโหว่ในการนำอุปกร์คอมพิวเตอร์ออกมาใช้ หรือนำไปขายโดยไม่ได้รับอนุญาต
2) Usability -> เพราะบุคลากรในโรงเรียนที่เป็นอาจารย์และเจ้าหน้าที่พัสดุอาจเป็นคนที่มีอายุ และอาจไม่ได้ถนัดในการใช้เทคโนโลยีมาก ดังนั้นระบบต้องเรียนรู้ได้ง่าย รวมถึงใช้งานง่ายและทำงานได้เสร็จสิ้นอย่างรวดเร็ว
3) Flexibility -> ระบบควรหยืดหยุ่นพอที่ในอนาคตจะสามารถรองรับการบริหารจัดการสิ่งของอื่นๆ นอกจากอุปกรณ์คอมพิวเตอร์ได้ เพื่อลดต้นทุนในการพัฒนาระบบใหม่ในอนาคต

5.
1) Functionality vs Usability -> ยิ่ง function การทำงานที่ซับซ้อน เช่น มีการกำหนดเงื่อนไขการนำอุปกรณ์ไปใช้ที่ซับซ้อน มีการออกแบบให้หนึ่งอุปกรณ์มีผู้ดูแลหลายคน หรือมีขั้นตอนการอนุมัติการขอใช้อุปกรณ์ที่ซับซ้อนหลายชั้น ยิ่งทำให้ Usability นั้นต่ำลงนั่นคือระบบจะใช้งานได้ยากขึ้น ทั้งสำหรับอาจารย์และเจ้าหน้าที่ฝ่ายพัสดุ
2) Security vs. Usability -> ยิ่งมีระบบความปลอดภัยที่หนาแน่น ยิ่งทำให้ประสบการณ์ผู้ใช้งานนั้นแย่ลง เช่น หากมีการนำ two-factor authentication มาใช้โดยให้มีการส่ง otp ไปที่มือถือของอาจารย์ จะทำให้ระบบใช้งานได้ยุ่งยากขึ้น